<div style="max-width: 800px">

<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
<h1>Simplify keyframes</h1>

<p>Let's take a moment to look at what we've built, and see if there might be ways to optimise things.</p>

<p>In this lesson we'll look at how we can make a more general-purpose set of keyframes that can be used in all manner of different ways, and eliminate some of the clutter from our CSS files.</p>

<p>To continue from the previous lesson, open the <a href="https://cssanimation.rocks/levelup/public/01/01.zip">sample code zip file</a> and look for folder <code>03-scroll-cue</code>.  A completed version of this lesson's code is in the folder <code>04-simplify-keyframes</code>.</p>

<h2>The power of the <code>animation</code> property</h2>

<p>When we use animations in CSS, we build our animations as series of keyframes. We then apply these keyframes to our elements using the <code>animation</code> property. While both are important, it turns out there's a lot of power we can pack into that <code>animation</code> property. We can control timing, duration, and even direction to create all sorts of very different styles of animation, even using the same original keyframes.</p>

<h2>Generic keyframes</h2>

<p>First let's take a look at our CSS. In the <code>header.css</code> file we have some sets of <code>keyframes</code> near the bottom. We'll focus on these three in particular.</p>

<pre><code>@keyframes fade-slide-down {
  0% {
    opacity: 0;
    transform: translateY(-4rem);
  }
  100% {
    opacity: 1;
    transform: none;
  }
}

@keyframes fade-slide-up {
  0% {
    opacity: 0;
    transform: translateY(4rem);
  }
  100% {
    opacity: 1;
    transform: none;
  }
}

@keyframes pop-in {
  0% {
    opacity: 0;
    transform: translateY(-4rem) scale(.8);
  }
  100% {
    opacity: 1;
    transform: none;
  }
}
</code></pre>

<p>There's a similar pattern to each of these keyframes. Each finishes in the same way at the "100%" keyframe. The starting "0%" keyframe is different, but they all end the same way. We could start by building a "no-transform" animation that looks like this.</p>

<pre><code>@keyframes no-transform {
  100% {
    opacity: 1;
    transform: none;
  }
}
</code></pre>

<p>It's worth noting, that you might see the "100%" here written as "to". When we have keyframes containing just a beginning and end state, we can refer to them as "from" and "to". It's up to you whether you want to use this approach. Either is fine.</p>

<p>You may also have noticed that just like in the "rotate-up" keyframes, we don't have a starting state. This is going to be useful when we apply the "no-transform" keyframes to our elements. </p>

<h2>Applying the keyframes</h2>

<p>In our <code>header.css</code> we begin with the <code>header:before</code> pseudo-element. We're using the "fade-slide-down" animation here. Instead, let's change it to use the "no-transform".</p>

<pre><code>header:before {
  animation: no-transform 2s .5s cubic-bezier(0, 0.5, 0, 1) forwards;
  background: linear-gradient(to bottom, rgba(0,0,0,0), rgba(0,0,0,.8)),
              url(../images/background.jpg) no-repeat bottom;
  background-size: cover;
  content: "";
  opacity: 0;
  transform: translateY(-4rem);
  position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
}
</code></pre>

<p>Just changing the <code>animation-name</code> isn't enough though - we need to set up the starting state for this animation in this code block. To do this we add <code>transform: translateY(-4rem);</code>.</p>

<p>Testing this in the browser, we should see no difference. The background animates by sliding down and fading in, just as before. </p>

<p>Let's try the title content next. Further down our CSS file you'll find a block for the <code>.animate-pop-in</code> class. This uses the "pop-in" keyframes. Let's change this to also use "no-transform" instead.</p>

<pre><code>.animate-pop-in {
  animation: no-transform .6s cubic-bezier(0, 0.9, 0.3, 1.2) forwards;
  opacity: 0;
  transform: translateY(-4rem) scale(.8);
}
</code></pre>

<p>Just like before we're also bringing in the <code>transform</code> that was in the keyframes, to set up the starting state. The "no-transform" keyframes only concern themselves with the end state. Again checking the browser, you'll see nothing has changed.</p>

<p>Next let's have the chevron at the bottom of the screen use the "no-transform" keyframes. In the <code>header-down-arrow img</code> block, change the animation name and add a <code>transform</code>.</p>

<pre><code>.header-down-arrow img {
  animation: no-transform 1s 1s ease-out forwards;
  opacity: 0;
  transform: translateY(4rem);
}
</code></pre>

<p>And finally we remove the three keyframes we're no longer using, "fade-slide-down", "fade-slide-up" and "pop-in".</p>

<p data-height="600" data-theme-id="light" data-slug-hash="OpbYzd" data-default-tab="result" data-user="donovanh" data-embed-version="2" data-pen-title="Landing page with simplified keyframes" class="codepen">See the Pen <a href="http://codepen.io/donovanh/pen/OpbYzd/">Landing page with simplified keyframes</a>.</p>

<p>The result should again look no different, but we've removed quite a lot of code, as well as creating a versatile little keyframes we can now apply any time we want an animation to end in a "non-transformed" state. </p>

<h2>Next: Waiting till the page is ready</h2>

<p>In this lesson we took a look at our CSS and found a way to streamline it. We created a handy set of keyframes we can reuse as needed, as well as saw how powerful the <code>animation</code> property can be.</p>

<p>In our next lesson we add more polish to our hero header by waiting till our image assets are ready before showing the content.</p>



</div>